<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8">
    <title>D3 Darstellung</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: sans-serif;
      }

      svg {
        width: 100vw;
        height: 100vh;
      }

      .node rect {
        stroke: steelblue;
        stroke-width: 2px;
        rx: 6;
        ry: 6;
        transition: all 0.3s ease;
      }

      .node text {
        font-size: 12px;
        pointer-events: none;
        text-anchor: middle;
      }

      .tooltip {
        position: absolute;
        text-align: left;
        padding: 6px;
        background: lightsteelblue;
        border: 1px solid gray;
        border-radius: 4px;
        pointer-events: none;
        font-size: 12px;
        max-width: 250px;
        word-wrap: break-word;
        opacity: 0;
        transition: opacity 0.3s ease;
        z-index: 10;
      }

      .highlight rect {
        opacity: 1 !important;
        stroke: darkblue;
        stroke-width: 3px;
      }

      .search-box {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1000;
        background: white;
        padding: 10px;
        border: 1px solid #ccc;
      }

      .search-box input {
        padding: 5px;
        font-size: 14px;
      }

      .search-box button {
        padding: 5px 10px;
        font-size: 14px;
      }

      .search-tag-box {
        position: fixed;
        top: 70px;
        left: 10px;
        z-index: 1000;
        background: white;
        padding: 10px;
        border: 1px solid #ccc;
        width: 250px;
      }

      .search-tag-box input {
        padding: 5px;
        font-size: 14px;
      }

      .search-tag-box button {
        padding: 5px 10px;
        font-size: 14px;
      }

      .nav-buttons {
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="Suche nach ITEMid...">
      <button onclick="searchItem()">Suchen</button>
    </div>

    <div class="search-tag-box">
      <input type="text" id="tagSearchInput" placeholder="Suche nach Tag...">
      <button onclick="searchTag()">Suchen</button>
      <div class="nav-buttons">
        <button id="prevTagButton" onclick="navigateTags('prev')">← Vorheriger</button>
        <button id="nextTagButton" onclick="navigateTags('next')">Nächster →</button>
        <button onclick="resetTagSearch()">Suche zurücksetzen</button>
      </div>
      <div id="tagResultsCount"></div>
    </div>

    <svg></svg>
    <div class="tooltip"></div>

    <script>
      const svg = d3.select("svg"),
            width = window.innerWidth,
            height = window.innerHeight;

      const g = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 4})`);
      const treeLayout = d3.tree().nodeSize([60, 160]);
      const tagColorMap = {
        AMOUNTFIELD: "brown",
        BLOCKBOX: "lightblue",
        BLOCKBUTTON: "orange",
        BLOCKREF: "green",
        CHECKBOX: "yellow",
        COMBOBOX: "red",
        DATEENTRYFIELD: "violet",
        ENTRYFIELD: "skyblue",
        EXPANDBUTTON: "pink",
        OUTPUTFIELD: "purple",
        STATICTEXT: "darkgreen"
      };

      // let tooltip = d3.select(".tooltip");
      // Создание tooltip для отображения описаний / Tooltip-Element erstellen
      let tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("display", "none");


      const urlParams = new URLSearchParams(window.location.search);
      const file = urlParams.get('file') || 'graph_data.json';
      const filename = file.split(/[\\/]/).pop();
      const fetchPath = `visualizer/${filename}`;
      const descriptionPath = `visualizer/specification.json?nocache=${Date.now()}`;

      let tagDescriptions = {};
      let rootData = null;

      Promise.all([
        fetch(fetchPath).then(res => res.json()),
        fetch(descriptionPath).then(res => res.ok ? res.json() : {})
      ])
      .then(([data, descriptions]) => {
        tagDescriptions = descriptions || {};
        rootData = d3.hierarchy(data, d => d.children);
        rootData.x0 = 0;
        rootData.y0 = 0;

        collapseAll(rootData);
        expandLevel(rootData, 1);
        update(rootData);
      })
      .catch(error => console.error("Fehler beim Laden:", error));

      function collapseAll(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapseAll);
          d.children = null;
        }
      }
      function findBlockParent(d) {
        let current = d.parent;
        while (current) {
          if (
            current.data.name &&
            (
              current.data.name.startsWith("BLOCK") ||
              [
                "ENTRYFIELD", "CHECKBOX", "COMBOBOX", "OUTPUTFIELD",
                "AMOUNTFIELD", "STATICTEXT", "DATEENTRYFIELD", "EXPANDBUTTON", "SELECTIONCTRL",
                "BITMAP", "GRIDCTRL", "FLASHBOX", "HTMLCTRL", "DOCEDITCTRL"
              ].includes(current.data.name)
            )
          ) {
            return current.data.name;
          }
          current = current.parent;
        }
        return null;
      }

      function expandLevel(d, level) {
        if (level > 0 && d._children) {
          d.children = d._children;
          d._children = null;
          d.children.forEach(child => expandLevel(child, level - 1));
        }
      }

      function update(source) {
        const treeData = treeLayout(source);
        const nodes = treeData.descendants();
        const links = treeData.links();

        g.selectAll(".link").remove();
        g.selectAll(".node").remove();

        g.selectAll(".link")
          .data(links)
          .enter().append("path")
          .attr("class", "link")
          .attr("fill", "none")
          .attr("stroke", "#ccc")
          .attr("stroke-width", 2)
          .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

        const node = g.selectAll(".node")
          .data(nodes)
          .enter().append("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${d.y},${d.x})`)
          .on("click", (event, d) => {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else if (d._children) {
              d.children = d._children;
              d._children = null;
            }
            update(source);
          })
          .on("mouseenter", (event, d) => {
            const tooltipLines = [];

            const tag = d.data.name;
            const block = findBlockParent(d);
            const desc = block && tagDescriptions[block] ? tagDescriptions[block][tag] : null;
            if (desc) {
              if (desc.frontend) {
                tooltipLines.push(`<strong>Frontend:</strong> ${desc.frontend}`);
              }
              if (desc.bedeutung) {
                tooltipLines.push(`<strong>Bedeutung:</strong> ${desc.bedeutung}`);
              }
            }

            if (d.data.text_content) {
              tooltipLines.push(`<strong>text_content:</strong> ${d.data.text_content}`);
            }

            if (d.data.value) {
              tooltipLines.push(`<strong>Wert:</strong> ${d.data.value}`);
            }

            if (tooltipLines.length > 0) {
              tooltip.html(tooltipLines.join("<br>"))
                .style("opacity", 1)
                .style("display", "block");

              const tooltipNode = tooltip.node();
              const { width, height } = tooltipNode.getBoundingClientRect();
              const pageX = event.pageX;
              const pageY = event.pageY;

              let left = pageX + 10;
              let top = pageY - 28;

              if (left + width > window.innerWidth) {
                left = pageX - width - 10;
              }

              if (top < 0) {
                top = pageY + 10;
              }

              tooltip.style("left", `${left}px`).style("top", `${top}px`);
              d3.select(event.currentTarget).classed("highlight", true);
            }
          })
          .on("mouseleave", (event, d) => {
            setTimeout(() => {
              tooltip.transition().duration(300)
                .style("opacity", 0)
                .on("end", () => tooltip.style("display", "none"));
              d3.selectAll(".highlight").classed("highlight", false);
            }, 50);
          });

        node.append("rect")
          .attr("x", -50)
          .attr("y", -15)
          .attr("width", 100)
          .attr("height", 30)
          .attr("fill", d => {
            const tag = d.data.name;
            const id = d.data.item_id;
            return id && id !== "Unbekannt" && tagColorMap[tag] ? tagColorMap[tag] : "lightgray";
          });

        node.append("text")
          .attr("x", 0)
          .attr("y", 0)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "central")
          .text(d => d.data.name);

        node.append("text")
          .attr("x", 0)
          .attr("y", 25)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "central")
          .attr("fill", "gray")
          .attr("font-size", "10px")
          .text(d => {
            const itemId = d.data.item_id;
            return itemId && itemId !== "Unbekannt" ? `${itemId}` : "";
          });
        node.filter(d => d.children || d._children)
          .append("text")
          .attr("x", 60)
          .attr("y", 0)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "central")
          .attr("font-size", "16px")
          .attr("fill", "darkblue")
          .text(d => d.children ? "🢃" : "➤");
      }

      let tagSearchResults = [];
      let tagSearchIndex = -1;

      function searchTag() {
        const searchValue = document.getElementById('tagSearchInput').value.trim();
        if (!searchValue) return;

        const tagToFind = searchValue.toUpperCase();

        function findNodeByTag(d) {
          let nodes = [];
          if (d.data.name && d.data.name.toUpperCase() === tagToFind) {
            nodes.push(d);
          }

          if (d.children) {
            d.children.forEach(child => nodes = nodes.concat(findNodeByTag(child)));
          }

          if (d._children) {
            d._children.forEach(child => nodes = nodes.concat(findNodeByTag(child)));
          }

          return nodes;
        }

        tagSearchResults = findNodeByTag(rootData);
        if (tagSearchResults.length > 0) {
          document.getElementById("tagResultsCount").innerText = `${tagSearchResults.length} Ergebnisse gefunden`;
          tagSearchIndex = 0;
          highlightTagNode();
        } else {
          document.getElementById("tagResultsCount").innerText = "Kein Ergebnis gefunden";
        }
      }

      function navigateTags(direction) {
        if (tagSearchResults.length === 0) return;

        if (direction === 'next') {
          tagSearchIndex = (tagSearchIndex + 1) % tagSearchResults.length;
        } else {
          tagSearchIndex = (tagSearchIndex - 1 + tagSearchResults.length) % tagSearchResults.length;
        }

        highlightTagNode();
      }

      function highlightTagNode() {
        const node = tagSearchResults[tagSearchIndex];
        collapseAll(rootData);
        expandToNode(node);
        update(rootData);
      }

      function resetTagSearch() {
        location.reload();



      }

      function searchItem() {
        const searchValue = document.getElementById('searchInput').value.trim();
        if (!searchValue) return;

        const itemIdToFind = searchValue.toUpperCase();

        function findNodeByItemId(d) {
          if (d.data.item_id && d.data.item_id.toUpperCase() === itemIdToFind) {
            return d;
          }

          if (d.children) {
            for (let child of d.children) {
              const found = findNodeByItemId(child);
              if (found) return found;
            }
          }

          if (d._children) {
            for (let child of d._children) {
              const found = findNodeByItemId(child);
              if (found) return found;
            }
          }

          return null;
        }

        const foundNode = findNodeByItemId(rootData);
        if (foundNode) {
          alert(`Gefundenes ITEMid: ${foundNode.data.item_id}`);
          collapseAll(rootData);
          expandToNode(foundNode);
          update(rootData);
        } else {
          alert("ITEMid nicht gefunden.");
        }
      }

      function expandToNode(d) {
        if (d.parent) {
          expandToNode(d.parent);
          d.parent.children = [d];
        }
        if (d.children) {
          d.children.forEach(child => expandToNode(child));
        }
      }

      svg.call(d3.zoom()
        .scaleExtent([0.5, 3])
        .on("zoom", event => {
          g.attr("transform", event.transform);
        }));
    </script>
  </body>
</html>
