<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>D3 Darstellung</title>
  <!-- Подключение библиотеки D3.js / Einbindung der D3.js-Bibliothek -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Стили для страницы и SVG-элементов / Stildefinitionen für die Seite und das SVG */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
    }

    svg {
      width: 100vw;
      height: 100vh;
    }

    .node rect {
      stroke: steelblue;
      stroke-width: 2px;
      rx: 6;
      ry: 6;
      transition: all 0.3s ease;
    }

    .node text {
      font-size: 12px;
      pointer-events: none;
      text-anchor: middle;
    }

    /* Стили для всплывающей подсказки / Tooltip-Styling */
    .tooltip {
      position: absolute;
      text-align: left;
      padding: 6px;
      background: lightsteelblue;
      border: 1px solid gray;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      max-width: 250px;
      word-wrap: break-word;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10;
    }

    /* Подсветка активного узла / Hervorhebung aktiver Knoten */
    .highlight rect {
      opacity: 1 !important;
      stroke: darkblue;
      stroke-width: 3px;
    }
  </style>
</head>
<body>
  <svg></svg> <!-- Контейнер для визуализации дерева / SVG-Container für die Baumdarstellung -->

  <script>
    // Установка размеров и контейнера SVG / Festlegen der SVG-Größe und des Hauptcontainers
    const svg = d3.select("svg"),
          width = window.innerWidth,
          height = window.innerHeight;

    // Группа, которая будет перемещаться вместе с деревом / Gruppe für Verschiebung des Baums
    const g = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 4})`);

    // Настройка layout для дерева / Baum-Layout mit nodeSize konfigurieren
    const treeLayout = d3.tree().nodeSize([60, 160]);

    // Цвета для разных типов тегов / Farbzuordnung für verschiedene Tag-Typen
    const tagColorMap = {
      AMOUNTFIELD: "brown",
      BLOCKBOX: "lightblue",
      BLOCKBUTTON: "orange",
      BLOCKREF: "green",
      CHECKBOX: "yellow",
      COMBOBOX: "red",
      DATEENTRYFIELD: "violet",
      ENTRYFIELD: "skyblue",
      EXPANDBUTTON: "pink",
      OUTPUTFIELD: "purple",
      STATICTEXT: "darkgreen"
    };

    // Создание tooltip для отображения описаний / Tooltip-Element erstellen
    let tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("display", "none");

    // Получение имени JSON-файла из параметра URL / JSON-Dateiname aus URL-Parameter holen
    const urlParams = new URLSearchParams(window.location.search);
    const file = urlParams.get('file') || 'graph_data.json';
    const filename = file.split(/[\\/]/).pop();
    const fetchPath = `visualizer/${filename}`;
    const descriptionPath = `visualizer/specification.json?nocache=${Date.now()}`; // предотвращение кэширования

    let tagDescriptions = {}; // Объект для описаний тегов / Objekt für Tag-Beschreibungen

    // Загрузка данных и описаний тегов / Daten und Beschreibungen laden
    Promise.all([
      fetch(fetchPath).then(res => res.json()),
      fetch(descriptionPath).then(res => res.ok ? res.json() : {})
    ])
      .then(([data, descriptions]) => {
        tagDescriptions = descriptions || {};
        const rootData = d3.hierarchy(data, d => d.children);
        rootData.x0 = 0;
        rootData.y0 = 0;

        collapseAll(rootData);      // свернуть все узлы / alle Knoten einklappen
        expandLevel(rootData, 1);   // развернуть только 1 уровень / nur erste Ebene anzeigen
        update(rootData);           // обновить визуализацию / Visualisierung aktualisieren
      })
      .catch(error => {
        console.error("Fehler beim Laden:", error);
      });

    // Функция сворачивания дерева / Funktion zum Einklappen aller Knoten
    function collapseAll(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapseAll);
        d.children = null;
      }
    }

    // Разворачивает дерево на заданный уровень / Expandiert Baum bis zur angegebenen Tiefe
    function expandLevel(d, level) {
      if (level > 0 && d._children) {
        d.children = d._children;
        d._children = null;
        d.children.forEach(child => expandLevel(child, level - 1));
      }
    }

    // Главная функция обновления дерева / Hauptfunktion zur Aktualisierung des Baumes
    function update(source) {
      const treeData = treeLayout(source);
      const nodes = treeData.descendants();
      const links = treeData.links();

      // Очистка предыдущих узлов и связей / Vorherige Knoten und Links entfernen
      g.selectAll(".link").remove();
      g.selectAll(".node").remove();

      // Отрисовка связей между узлами / Zeichnen der Verbindungen zwischen den Knoten
      g.selectAll(".link")
        .data(links)
        .enter().append("path")
        .attr("class", "link")
        .attr("fill", "none")
        .attr("stroke", "#ccc")
        .attr("stroke-width", 2)
        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

      // Отрисовка узлов / Zeichnen der Knoten
      const node = g.selectAll(".node")
        .data(nodes)
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.y},${d.x})`)
        .on("click", (event, d) => {
          // Переключение состояния: свернут / развернут / Ein-/Ausklappen beim Klick
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else if (d._children) {
            d.children = d._children;
            d._children = null;
          }
          update(source);
        })
        .on("mouseenter", (event, d) => {
          // Отображение tooltip / Tooltip anzeigen
          const tooltipLines = [];

          const tag = d.data.name;
          const desc = tagDescriptions[tag];
          if (desc) {
            if (desc.frontend) {
              tooltipLines.push(`<strong>Frontend:</strong> ${desc.frontend}`);
            }
            if (desc.bedeutung) {
              tooltipLines.push(`<strong>Bedeutung:</strong> ${desc.bedeutung}`);
            }
          }

          if (d.data.text_content) {
            tooltipLines.push(`<strong>text_content:</strong> ${d.data.text_content}`);
          }

          if (d.data.value) {
            tooltipLines.push(`<strong>Wert:</strong> ${d.data.value}`);
          }

          if (tooltipLines.length > 0) {
            tooltip.html(tooltipLines.join("<br>"))
              .style("opacity", 1)
              .style("display", "block");

            const tooltipNode = tooltip.node();
            const { width, height } = tooltipNode.getBoundingClientRect();
            const pageX = event.pageX;
            const pageY = event.pageY;

            let left = pageX + 10;
            let top = pageY - 28;

            if (left + width > window.innerWidth) {
              left = pageX - width - 10;
            }

            if (top < 0) {
              top = pageY + 10;
            }

            tooltip.style("left", `${left}px`).style("top", `${top}px`);
            d3.select(event.currentTarget).classed("highlight", true);
          }
        })
        .on("mouseleave", (event, d) => {
          // Скрыть tooltip / Tooltip ausblenden
          setTimeout(() => {
            tooltip.transition().duration(300)
              .style("opacity", 0)
              .on("end", () => tooltip.style("display", "none"));
            d3.selectAll(".highlight").classed("highlight", false);
          }, 50);
        });

      // Прямоугольник узла / Rechteck für den Knoten
      node.append("rect")
        .attr("x", -50)
        .attr("y", -15)
        .attr("width", 100)
        .attr("height", 30)
        .attr("fill", d => {
          const tag = d.data.name;
          const id = d.data.item_id;
          if (id && id !== "Unbekannt" && tagColorMap[tag]) {
            return tagColorMap[tag];
          }
          return "lightgray";
        });

      // Название тега / Tag-Name anzeigen
      node.append("text")
        .attr("x", 0)
        .attr("y", 0)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .text(d => d.data.name);

      // Отображение item_id, если он есть / item_id anzeigen, falls vorhanden
      node.append("text")
        .attr("x", 0)
        .attr("y", 25)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .attr("fill", "gray")
        .attr("font-size", "10px")
        .text(d => {
          const itemId = d.data.item_id;
          return itemId && itemId !== "Unbekannt" ? `${itemId}` : "";
        });

      // Стрелка раскрытия для родительских узлов / Aufklapp-Pfeil für Knoten mit Kindern
      node.filter(d => d._children || d.children)
        .append("text")
        .attr("x", 60)
        .attr("dy", 4)
        .attr("fill", "darkblue")
        .attr("font-weight", "bold")
        .attr("cursor", "pointer")
        .text("➤")
        .on("click", (event, d) => {
          event.stopPropagation();
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else if (d._children) {
            d.children = d._children;
            d._children = null;
          }
          update(source);
        });
    }

    // Включение масштабирования и перетаскивания / Zoom und Verschiebung aktivieren
    svg.call(d3.zoom()
      .scaleExtent([0.5, 3])
      .on("zoom", event => {
        g.attr("transform", event.transform);
      }));
  </script>
</body>
</html>
